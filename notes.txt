9/28/16
SoftDev:

Aim: Requesting assistance

request object
	stores information about incoming requests.
ex:
from flask import Flask, render_template, request

ex (from flasktest.py):
print request.headers
return render_template( "form.html" )

prints:
Referer: http://127.0.0.1:5000/
Content-Length:
User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:48.0) Gecko/20100101 Firefox/48.0
Connection: keep-alive
Host: 127.0.0.1:5000
Upgrade-Insecure-Requests: 1
Cache-Control: max-age=0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Content-Type:
Accept-Encoding: gzip, deflate

HTML:
<form action="/msg/">
<textarea name = "message" rows = "6" cols= "40"></textarea>
Python:
@app.route( "/msg/" )
def auth():
    print request.headers
    print request.args
    print request.args["message"]
    return "You good"


9/29/16
Systems:

Aim: Make so

Make
	Create compiling instructions and setup dependencies
	Standard name for the file is the makefile.

	Syntax:
		<target><dependencies>
		TAB<rules>


	strtest: stringy.c
		 gcc stringy.c

	clean:
		rm *~


	make clean would remove all emacs save files
	(files with ~ at the end of filename).


SoftDev:

Aim: Dont forget to include POSTage
DN: Open up yesterday's flask app

request.headers
	HTML headers sent from borwser
request.method
	the request method (GET/POST)
request.args
	the arguments in a query string from a GET request
request.form
	the arguments sent in a POST request
request.args and request.form are immutable dictionaries.

the u in the dictionary is unicode (string)

9/30/16
SoftDev:

Aim: Always Serve Your Passwords With A Side of Hashbrowns

Hash function
     function designed to take in an arbitrary amount of data and return a fixed
      size sequence of bits called a "hash digest" or simply, hash.

      Hash digests are useful for storing certain kinds of sensitive information.

Creating a had digest in python:
	 hashlib
		python module for generating has digests with different
		algorithms

		ex:
			md5 (bad), sha1, sha224, sha256, sha384, and sha512 (spits more bytes)

		ex:
		import hashlib
		hashlib.md5("12345")
		hashlib.md5("12345").digest() -> returns as string as attempted
		ASCII (looks messy w/ "\x")

		hashlib.md5("12345").hexdigest() -> gives savable string as hex

		hashlib.sha1("12345").hexdigest() -> longer
		hashlib.sha512("12345").hexdigest() -> much longer hex values

10/5/16
Systems:

Aim: If these files won't behave, we'll have to separate them!

DN: Demo.

crazy one line version of strlen:
int len(char *s) {
    return *s?1+len(*++s):0;
}

dw strcat:
char * dwstrcat( char * s1, char *s2 ) {
     char * p;
     p = s1 + len( s1 );
     dw strcpy(p);
     }

separate compilation:
	 You can combine multiple c files into a c program by
	 including them all in one gcc command.
	     ex:
		gcc test.c string.c foo.c woohoo.c

	 You cannot have duplicate function or global variable names
	 across these files.
	 	ex: main()


one solution: make file w/o main
    ex: #include "dwstring.h"
    	void main() { ... }


	$gcc dwstrtest.c dwstring.c

SoftDev:

Aim: C is for Cookie, but Sessions are Secure

DN: Demo.

How to keep track who is logged in:

Cookies are files that websites will save to your web browser
to store information on a local machine.

Useful for keeping track of persistent information like login credentials.

They have been around for a long time (not new).

A session is a securely signed cookie. They are encryted and cannot be modified
by the local machine.

A session object works exactly like a dictionary:
  add data to a session:
  session[KEY] = DATA
  	       ex: session['user'] = request.form('user')

  remove data from a session:
  session.pop(KEY)
	ex: session.pop('user')

  In order to encrypt session, need a private key in our app:
     APP.secret_key = <RANDOM STRING>

     		    get random data: os.urandom(32)
		    returns 32 random bits of data as string.

10/6/16
Systems:

Aim: malloc & free: The dynamic duo!

     gcc -c dwstring.c main.c  = compile but not make it executable

     -> dwstring.o main.o

     gcc dwstring.o main.o

     -> a.out


.o files can be linked together with .c files through gcc

gcc -o specify name of executable file

gcc would try to make file executable, gives error if "main" is missing.


void * malloc(int x)
	   memory is not initialized (allocates x bytes of memory from the heap)
	   generates generic pointer return, able to typecaste to appropriate
	   pointer.

free(void *ptr)
     releases previously allocated memory.

void * calloc(int n, int x)
     allocates n * x bytes of memory
     ensures each bit = 0
     generates generic pointer return, able to typecaste to appropriate pointer.

void * realloc(void *ptr, int x)
     takes a pointer and changes the amount of memory allocated to given block

     ptr must be a pointer to the beginning of an allocated block of memory, but it does not have to be the original pointer.


SoftDev:

Aim: Url binding is the art of redirection

     app.secret_key = os.urandom(32)
     that could log out all of the users when app is restarted.

     ex:
     print url_for( "login" )
     uses associated function to build correct url

     redirect
     Flask fxn that will redirect a call to one route to a different response
     used in combination with url_for
     	  ex:
		redirect( url_for('login') )

10/7/16
Systems:

Aim: Structural Programing

void *
     the dynamic memory functions deal in arbitrary blocks of memory.
     There is no regular type associated with the block.

     void * is considered to be a pointer to a 1 byte block of memory,
     so pointer arithmetic will be based on 1.

ex:
  int *p;
  p = malloc( 5 * sizeof(int) ); //same as calloc( 5, sizeof(int) )

  p[0] = 2;
  printf( "p[0]: %d\n", 0[p] );

ex:
  int *ip;
  ip = (int*)malloc( 20 * sizeof(int) );


Struct
	A collection of values in a single data type
	struct { int a; char x; } s; sizeof(s) -> 8 (does units of 8 bytes)
	|-----------------------|
	  s is a type that has an int and char

	  here, s is a variable of type struct { int a; char x; }


	struct foo { int a; char x; };
	       in this example, foo is a prototype for this kind of struct
	       to be used later.

	struct foo s;
	we use the . oparator to access values in a struct:
	   ex:
		s.a

	We use the . operator to access a value iside a struct
	   s.a = 10;
	   s.x = '@';

	   . binds before *
	     to access data from a struct pointer you can either:
	     	struct foo *p;
		p = &s;
		(*p).x;
			or...
		p->x;

10/11/16
Systems:

Aim: Get Dem Bugs

What is wrong with this fxn?
struct node * insert_front( struct node * n, int i ) {
       struct node new;

       new.i = i;
       new.next = n;

       return &new;

}
The fxn is reasonably okay, but it is stack memory (new and its variables will be popped).
The only time memory is allocated dynamically is by using malloc, calloc, ect.

Typedef
	provide a new name for an existing data type
	typedef <real type> <new name>;

	ex:
		typedef unsigned long size_t;
		size_t x = 139; //really an unsigned long

		typeof short[10] list;
		list a;
		typeof char * String;

		typedef struct foo { int a; char x; } bar;


gdb (GNU Debugger)
    allows you to get detailed information about a program while it is running.

    ex: gdb a.out

    quit = quit gdb
    list = lines of code around error

    ex: break 10 = set a breakpoint at line 10

    print <VAR> = prints a variable

    backtrace = show the currect stack


valgrind
	debugging tools specializing in memory values.


	valgrind --leak-check=yes ./a.out
		 checks memory leaks


9/13/16
Softdev:

Aim: All your data are belong to us.

Relational database
	   Database that stores information as a collection of tables.

	   Field: column data in a RDB
	   Record: row in a RDB
	   Data can be linked between tables based on field values.

ex:
Students
name:	| id:
-------------------
amy	| 0
reo	| 1
emma	| 3


Class
name:	| student id:	| grade
------------------------------------
softdev	| 0		| 100
softdev	| 1		| 100


the id is related to the id in the students table


SQL (Structured Query Language)
    Standard language designed to work with relational databases.

    Is used for many major db programs, though the implementations may not
    (mostly are not) compatible.

    MySQL, PostgreSQL, SQLite, Oracle are different SQL implementations.

SQLite
	SQL implementation that relies entirely on functions calls in the parent
	program. There is no database server.

	All database information is stored in a single file.

	Data is dymanically typed as values are inserted into a table.

Basic SQLite Operations
      CREATE TABLE
      	     Add a table to a database
	     CREATE TABLE <name> (<column name> <data type>, ... )
	     	    The data type will help to convert entered values to a
		    suggested type.

		    TEXT, INTEGER, REAL, NUMERIC, BLOB
		    	  NUMERIC will default to an integer, but can be a float.

			  BLOB means no suggested type.

ex:
	$ sqlite3 school.db
	...>CREATE TABLE students (name TEXT,...);
	.tables = show the tables
	INSERT INTO students VALUES ("amy", 0);
	INSERT INTO classes VALUES ("softdev", 0, NULL );


	Columns can be given a PRIMARY KEY attribute.
	denoting that every entry in that column is unique and cannot be NULL

	Columns can be given NOT NULL attribute, denoting that no entry can be NULL.
	INSET INTO
	      Insert a record into a table
	      INSERT INTO <name> VALUES ( <field 1>, <field 2> ... )
	      	     Will add a record to a table matching the values to the columns in order.

	NULL can be used in any entry.

	SELECT * FROM <name>; = select everything from a table

SQLITE Shell commands
       .quit
       .tables
       .header on|off
       .mode column|csv|list|html|insert|line|tabs

10/17/16
SoftDev:

Aim: sqlite, the low-fat alternative to SQL

python sqlite module
        import sqlite3

        connect
		open/create an sqlite database.

    		If the database does not exists, create it.
		   db = sqlite3.connect(<db name>).

        cursor
		Create a database cursor object that will allow you to perform
		operations of the databse.

		c = db.cursor()

        execute
		cursor method to perform the provided SQL operation, given as a
		string.

		c.execute( <SQL statement> )

	commit
		database method to save changes to the db

		db.commit()

	db.close()


	formatting strings in python:
		   '(' + x + ', ' + y + ') is a point'
		       =
		   '(%d, %d) is a point'%(x, y)


		   %d = decimal integer
		   %f = floating point
		   %s = string

	ex:
	command = 'INSERT INTO students VALUES ("%s", %d, %d'%(students['name'], ...

SQL SELECT Statement
    Used to get data from a database
    Creates a results table based on the query
    SELECT <column 1>, ... FROM <table 1>, ...;
    	   Will return a new table containing only the requested columns from the requested
	   tables.

	   ex:
		SELECT name FROM students;
		SELECT * FROM students; -> gives everything from students
		SELECT name, id, code FROM students, courses; -> needs to specify
		    solution:  ->  students.id

10/18/16
Systems:

Aim: C, the ultimate hipster, using # decades before it was cool

ex:
	#include "link_list.h"
	->if you include 2 .h files, where one .h file includes another .h file,
	the .h file would be included twice. That is problematic.

#
	used to provide preprocessor instructions
	these directives are handled before the compler really kicks in.
	NOT regular c syntax
	gcc basically goes and copies content of the header file to where "include" is

	#include <library> or "LIBRARY"
		 link libraries to your code.

	#define <NAME> <VALUE>
		"find and replace" all occurances of NAME with VALUE

		ex:
			#define TRUE 1
				TRUE is not a variable, and doesn't get replaced in a string.

		macros:
			#define SQUARE(x) x*x (not a fxn)
			...
			int y = SQUARE(9); -> int y = 9 * 9;
			    DOESN'T COMPUTE 9*9!!

		conditional statement:
		#ifndef (if not defined) <IDENTIFIER>
		<CODE: deal with whatever is in here>
		#endif

		if the identifier has to be defined ignore all the code up until the
		endif statement.

		ex:
			#ifndef LINK_LIST_H
			#define LINK_LIST_H
			...

		also:
			#define FOO 5
			a[FOO] would be fine since FOO would be replaced.

	rand(), srand(int), sranddev()
		srand(int) = sets a seed, can be used as srand( time(t sec since epoch) )
			   time(NULL) needs #include <time.h>
		sranddev() = seed rand() with random number
			   (linux has a "file" that generates random values)
		rand() = random number generator

SoftDev:

Aim: WHERE did I put that data?

WHERE
	allows you to put restirctions on the results of a SELECT statement.

	ex:
		SELECT * FROM courses WHERE mark < 65;

		can use single = sign for equality test

	ex:
		select name, students.id, courses.id, code, mark from students, courses where students.id = courses.id and mark > 70;
		name        id          id          code        mark
		----------  ----------  ----------  ----------  ----------
		kruder      1           1           systems     75
		kruder      1           1           ceramics    99
		dorfmeiste  2           2           softdev     75
		dorfmeiste  2           2           ceramics    98
		sasha       3           3           greatbooks  85
		digweed     4           4           softdev     75
		bassnectar  6           6           ceramics    90
		bassnectar  6           6           systems     90
		bassnectar  6           6           softdev     99
		TOKiMONSTA  7           7           systems     88
		TOKiMONSTA  7           7           softdev     85
		jphlip      8           8           systems     98
		alison      10          10          systems     85
		alison      10          10          softdev     80


10/19/16
Systems:

Aim: A bit of operators

>> and << are binary operators.

int i = 30;
i = i>>2;
    i -> 8 (shifted values 2 bits to the "right", and added 2 0s in the front)
i = i<<2;
    i -> 28 (NOT 30)

~ negation
  flips every bit

  ex:
	00001 -> 11110

| or, & and
  ex:
	a | b -> 10010 | 01010 -> 11010
	a & b -> 10010 & 01010 -> 00010

    perform or/and for each pair of bits in (a, b)

^ xor
  ex:
	a ^ b

	perform xor for each pair of bits in (a, b)



10/21/16
Systems:

Aim: File this under useful information.

File permissions:
     read, write, and execute

     3 digit binary #s or 1-digit octal
     100 -> read only
     111 -> read, write, and execute


     3 permission areas: owner/user, group, other
     3-digit octal number
     	     ex: 644 -> user: read + write, group+other: read
	     default: -rw-r--r-- (644)

	     directories are also files (that contain a list of files they contain)
	     (look = read, add files = write, cd into directory = execute)
	     your id is in the metadata (data about data) in the file.


     File table:
     	  A list of all the files that is used by a program while it is running.
	  Contains basic info such as location and size.

	  has a limited size, which is a power of 2 and commonly 256 files (not bytes), and
	  getdtablesize() will return this size.

	  each file is given an integer index (starts at 0) and referred to as file descriptor
	  3 files are always open in the table:
	    	  0 or STDIN_FILENO: stdin
		  1 or STDOUT_FILENO: stdout
		  2 or STDERR_FILENO: stderr (standard error)
		  (they are links)

10/24/16
Aim: Opening up a world of possibilities

open/close
	-open: takes path string, what type of access (ex append) and optionally permission. returns int of -1 if unsuccessful.
	-close: closes file associated with handle and returns 0 if unsuccessful and -1 if error.

read/write
	-read: read( int rd, void *buf, int count )
	       read operation that attempts to read count bytes from buf associated with rd.
	-write: writes count bytes from buf to the file associated with rd.


open - <fcntl.h>
     add a file to the file table and returns its file descriptor

     if fails, -1 is returned, extra error infrmation can be found in errno.

     	errno is an int variable that can be found in <errno.h>, using strerror (in string.h)
	on errno will return a string decription of the error

	open( <PATH>, <FLAGS>, <MODE> )

	mode
		only used when creating a file. set the new files permissions using a 3 digit octal # (have a leading 0)

	ex:

	fd = open( "tester", O_RDONLY ); -> 3 if successful (0, 1, and 2 are taken)
	printf( "error: %d - %s", errno strerror(errno) );

	flags
		Determine what you plan to do with the file.
			 O_RDONLY
			 O_WRONLY
			 O_RDWR
			 O_APPEND
			 O_TRUNC
			 O_CREAT (create)
			 O_EXCL: (exclusive) only works when combined with O_CREAT, will return error if file exist


Each flag is a number, to combine flags we use bitwise or
     O_WRONLY = 1
     O_APPEND = 8
     O_WRONGLY | O_APPEND = 00001001


close - <unistd.h>
      remove a file from the file table (0 if successful)

      close( <FILE DESCRIPTION> );

10/24/16
Systems:

Aim:

umask - <sys/stat.h>
      set the file creation perission mask
      By default, created files are not given the exact permissions provided in the mode argument to open. Some permissions are automatically shut off. (ex: 0666 != rw-r--r--)

      Umask is applied by using bitwise negation on the mask, then bitwise and and-ing it to the mode
      new_permissions = ~umask & mode

      default umask = 0022.


So here, we get:
   umask:  000 010 010

   ~umask: 111 101 101
   & mode: 110 110 110
   -------------------
   result: 110 100 100

umask( <MASK> )
       ex: umask( 0000 ); -> everything is on
       	   umask( 0111 ); -> no execute permission

Read = take data from storage and dump into memory
read - <unistd.h>
     read( <file descriptor>, <buffer>, <amount> )
     read( fd, buff, n )

     same errno stuff ( -1, ect. ) as open
     read n bytes from the fd's file and put that data into buff

     returns the number of bytes actually read (if successful).
     buffer must be a pointer (doesn't naturally have to be a string).
     	    	 -can read integers if the file has actual numbers


write - <unistd.h>
      "twin" of read
      write n bytes from buff into fd's file

      returns the number of bytes actually written. Same errno stuff as open/read.
      buffer must be a pointer.


10/27/16
Systems:

Aim: Seek and ye shall find

-write raw byte data into txt file
       reads the int one byte at a time and attempts to read it as ASCII

lseek - <unistd.h>
      Set the current position in an open file
      lseek( <FILE DESCRIPTOR>, <OFFSET>, <WHENCE> )

      offset = # of bytes (can be negative)
      whence = where to measure offset from
      	     SEEK_SET
		offset is evaluated from the beginning of the file

	     SEEK_CUR
		offset is relative to the current position in the file

	     SEEK_END
		offset is evaluated from the end of the file

	returns the # of bytes the current position is from the beginning of the file

ex:
	int b = write(fd, r, sizeof(r) );

	lseek( fd, 0, SEEK_SET )
	int x;
	read( fd, &x, sizeof(int) );
	printf( "x: %d\n", x );
	printf( "b: %d\n", b );



10/28/16
Systems:

octal permission: ex: 100644
      1 is a regular file, 4 is a directory


Softdev:

Stuff we can add:
being_edited = boolean when user in middle of editing story

11/1/16
Systems:

Aim: Where fo compsci priests live? - In directory!

sprintf:
	print formated string into a string.

calloc guarantees terminanting null.

convert octal to string rwx:

perms[0] = (mode & 0b11000000) >> 6;
perms[1] = (mode & 0b111000) >> 3;
perms[2] = (mode & 0b111);

or:
110 100 100

if( mode & 256 )
    perm_string[0] = 'r';


Directories:
	A *nix directory is a file containing the names of the files within the
directory along with basic information like file type.

	Moving files into/out of a directory means changing the directory file.
not actually moving any data.

opendir - <dirent.h>
	open a directory file.

	This will not change the cwd, it only allows your program to read the
contents of the directory file.

	 opendir( <PATH );

	 returns a pointer to a directory stream (DIR *)

closedir - <dirent.h>
	 closes the directory stream and frees the pointer associated with it.

	 closedir( <DIRECTORY STREAM> )

readdir - <dirent.h>

	readdir( <DIRECTORY STREAM> )

	Returns a pointer to the next entry in a directory stream, or NULL if all entries have already been returned.

	struct dirent - <sys/types.h>
	       Directory struct that contains the information stored in a directory.

SoftDev:

Aim: Extending your template knowledge.

Extending HTML templates
	  any template can be inherited by others
	  To extend a template: {% extends "<TEMPLATE>" %}

	  You can define sections to override inside.
	  ex: (content is a name)

	  {% block content %}

	  {% endblock %}

Note about directories (Systems):
	// . refers to directory itself and .. refers to the parent directory


11/3/16
Systems:

Aim: Input? fgets about it!

stat provides metadata (doesnt open file)

getcwd - <unistd.h>
       get the current working directory (cwd) of a program

       getcwd( <STRING BUFFER>, <SIZE> )
       	       copies the path to the cwd into the buffer argument (char * )
	       copies at most SIZE characters of the path

       ex:
       char path[100];
       path[99] = 0;
       getcwd(path, 99);
       printf( "current directory: %s\n", path ); -> gets absolute path

chdir - <unistd.h>
      change the working directory of a program

      chdir( <PATH> )
      	     returns 0 if successful, -1 (errmo) if not
	     keep track of file paths when using chdir!

      chdir( ".." );
      getcwd(path, 99);
      printf( "current directory: %s\n", path ); -> now prints parent directory


Command Line Arguments:

	int main( int argc, char *argv[] )
	program name is considered the first command line argument

	argc
		number of command line arguments

	argv
		array of command line arguments


	ex:
	while( argc ) {
	       argc--;
	       printf( "%d: %s\n", argc, argv[argc] );
	}

scanf - <stdio.h>
	scanf( <FORMAT STRING>, <VAR 1>, <VAR 2>, ... );

	ex:
	int i; float f;
	scanf( "%d-%f", &i, &f );


11/4/16
Systems:

Aim: Sending mixed signals

fgets - <stdio.h>
    Read in from a file stream and store it in a string
    fgets(<DESTINATION>, <BYTES>,< FILE POINTER>)

    File pointer
        FILE * type, more complex than a file descriptor
        stdin is a FILE * variable

    Stops at newline, EOF, or the byte limit.
    If applicable, keeps the newline character as part of the string, appends NULL after

Signals
    Limited way of sending information to a process.
    kill
        Command line utility to send a signal to a process
        $ kill <PID>
            Sends signal 15 (SIGTERM) to PID

the command "ps" shows a list of running processes that were run from a terminal
	"ps -ax" shows ALL processes

PID is process id
All process information can be found in /proc/<PID>

11/7/16
Systems:

Aim: Are your processes running? - Then you should go out and catch them!


Processes
	Every running program is a process. A process can create subprocesses,
	but these are no different from regular processes.

	A processor can handle 1 process per cycle (per core). "Multitasking"
	appears to happen because the processor switches between all the active
	processes quickly.

pid
	Every process has a unique identifie called the pid.
	pid 1 is the init process
	each entry in the /proc directory is a current pid.

getpid() - <unistd.h>
	 returns current process' pid

getppid() - <unistd.h>
	 returns current process' parent pid

Signals
	Limited way of sending information to a process.

	kill
		command line utility to send a signal to a process

		$kill <PID>
		      sends signal 15 (SIGTERM) to PID

		$kill -9 <PID> will give a different signal
		      (Killed: 9 is different from the default Terminated: 15)

		killall [-<SIGNAL>] <PROCESS>
			sends sigterm (or signal if provided) to all processes
			with process as the name

Signal handling in c programs <signal.h>
       kill
	kill(<PID>, <SIGNAL>)
		    returns 0 on success or -1 (errno) on failure.

Sighandler
	To intercept signals in a c program you must create a signal handling
	function.

	Some signals (like SIGKILL) cannot be caught.

	static void sighandler( int signo )
		Must be static, muct be void, must take a single int parameter.
		static: the function can only be called from within the file it
		is defined.

	in main attatch:
	   signal( SIGINT, sighandler );

sleep(1); wait 1 second before "spamming"


11/10/16
Systems:

Aim: What the fork?

fork: "forks" a new process (make a sub (new) process)
(ex: bash: command -> subprocess ->bash)

The child process runs on its own. They don't share information and
can have some intercations (signals).


fork() - <unistd.h>
       Creates a separate process based on the current one, the new process is
       called the child, the original is the parent.

       The child process is a duplicate of the parent process. All parts of the
       parent process are copied, including stack and heap memory, and
       the file table.

       Returns 0 to the child and the child's pid to the parent or -1 (errno).
       (the child gets a return value (0) from fork and the parent will get the
       pid of the child or -1 (if fails-no child).)

       If a parent process ends before the child, the child's new parent pid is 1.


       ex:
       int f;
       printf(pid)
       f = fork();
       printf(pid) -> now run by 2 processes (parent does not always execute 1st (more like
       child finishes, then parent comes back))
       if the parent finishes its function, and the child has not, the ppid would print 1.

       look at return value of fork to assign different tasks.


11/15/16
Systems:

Aim: Wait for it...

f = fork();
if( f == 0 )
    printf("I'm a child: %d, parent: %d\n", getpid(), getppid());
else
    printf("I'm a parent! f = %d\n", f);

printf( "almost done!\n" );


But what about threads you ask?
    A quick note on threads: A thread is a separate executable entity similar
    to a child process, except a thread is not a standalone process.

    It does not have its own memory space, instead it shares its parent's
    memory. But shares info more quickly.


to make child run before parent, we can fake it:
   use: sleep(1);

   better:
	wait - <unistd.h>

		Stops a parent process from running until any child has provided
		status information to the parent via a signal.
		(usually the child has exited)

		returns the pid of the child that exited, or -1 (errno)

		wait( int *status )
		      The parameter (status) is used to store information about
		      how the process exited.

ex:
else {
     int status, r;

     r = wait( &status );
     printf("I'm a parent! f = %d\n", f);
     printf("wait returned: %d  status: %d\n", r, status);
     printf("WEXITSTATUS: %d\n", WEXITSTATUS(status) );
}


Softdev:

Aim: Stuylin'

CSS - Cascading Style Sheets

    Created to separate the presentation of an html/xml page and its content

    Basic syntax:

    	  PROPERTY: VALUE;

	  ex:
		color: lightsteelblue;


	  There are 3 ways to incorporate css into a page;
	  inline, style sheet, external style sheet.

	  inline: least useful
	  <TAG style="CSS CODE">

	  ex:
	  <p style="color: green; font-size: 2em;">...</p>

11/16/16
Systems:

Aim: Time to make an executive decision.

execlp:
	takes command line args as strings.

	int execlp( const char *filename, const char *arg, ... )

execvp:
	takes command line args as an array.

	int execvp( const char *filename, char *const argv[] )

	run executables by filename and argv is an array of null-terminated
	strings to provide a value of the argv in the main function of the
	executable file.
	(appropriate arguments to the file/command line arguments).

	if no slash exists in filename, will look through the PATH environment
	variable.

Both:
	<unistd.h>

	run executables and REPLACE CURRENT PROCESS.
	takes over process including pid

	returns -1 and set errno only if theres an error.


ex:
  char* file = "ls";
  char * arg[3]; //command line arguments
  arg[0] = "ls";
  arg[1] = "-al";
  arg[2] = NULL;

  int i = execvp( file, arg );
  printf( "Return: %d - error: %s\n", i, strerror(errno) );


ex:
  execlp( "ls", "ls", "-l", NULL );


SoftDev:

Anything in the <head> loads first.

External Style Sheet:
in <head>:
   <link rel="stylesheet" type="text/css" href="STYLE FILE">


11/17/16
Systems:

Aim: Let's take this to delimit!

specify path with execl
execl( "/bin/ls", "ls", "-l", NULL );

char * command[3]; - > array of pointers, but is NOT a null terminated string
     *the 3 pointers are going to assigned to immutable strings*

ex:

	command[0] = "ls";
	command[1] = "-l";
	command[2] = NULL;

	//command[1][1] = 'a'; -> will create an error if added
	/*
		char command[3][4]; -> ([][][][])([][][][])([][][][])
		//can't do s[4] = "hello"; -> only during declaration
		//must use string functions instead
	*/

	execvp( command[0], command );


strsep - <string.h>

       Used for parsing a string with a common delimeter

       strsep( <SOURCE>, <DELIMETER> )

       Locates the first occurrence of the delimeter in a string and replaces
       that character with NULL
       *only strsep with mutable strings!*

       Returns a pointer to the beginning of the original string,
       sets the source string to the string starting at 1 index past the
       location of the new NULL.

       Since the source variable's value is changed, it must be a pointer to a
       string.

       To parse again, loop it.

ex:

	char line[100] = "hello-this-is-cool";
	char *s = line;
	char *p;
	while( s ) {
	       p = strsep( &s, "-" );
	       //no new memory is used (s is mutable pointer)

	       printf( "s: %s\n", s );
	       printf( "p: %s\n", p );
	}

SoftDev:

Aim: Stay classy, css.

class ex:
      <h2 class="new_chapter bold">...</h2>

Classes are specified using a . before the class name.

ex:
	.hello {
       	       font-family: "Times New Roman", Times, serif; //specific -> general
	       }

id ex:
   <div id="main_content">...</div>

ids are specified using a  # before the id name.


11/22/16
Systems:

Aim: Redirection; how does it ... SQUIRREL

File Redirection
     Changing the usual input/output behavior of a program

Command line redirection
 >
	redirects stdout to a file
	overwrites the contents of the file

	<COMMAND> > <FILE>
	ls > file_list

 >>
	redirects stdout to a file by appending


cheap text editor:
      cat > foo

      takes stdin and puts them into a file caled foo

2>
	redirects stderr to a file
	OVerwrites the file (2>> appends)

0: stdin
1: stdout
2: stderr

&>
	redirect stdout and stderr

<
	redirects stdin from a file
ex:
	cat > line; ls -a -l
	./a.out < line (from executor)
	immediately executes command. as soon as it reads it, it already gets
	the input, so it doesn't print "what would you like to do?".

| (pipe)
	redirect stdout from one command to stdin of the next
	ls | wc (takes output of ls to the stdin of wc)


dup2 - <unistd.h>
     redirect one file descriptor to another

     dup2( fd1, fd2 )
     	   Redirects fd2 to fd1
	   Lose any reference to the original fd2, that file is closed.


0: stdin
1: stdout -> closed -> foo.txt
2: stderr		|
3: foo.txt		v (directs to 3, lose reference to stdout)


dup - <unistd.h>

    Duplcates an existing entry in the file table
    Returns a new file descrptor for the duplicate entry

    dup(fd)
	returns the new file descriptor

ex:
	dup(1) -> creates a new file descriptor (stdout)
	dup2(3, 1) -> now foo.txt is in 1, but stdout is still in the file table at 4.




11/23/16

fgets GETS EVERYTHING (INCLUDING THE \N YOU ENTER)

*(strchr(line, '\n')) = NULL; sets the '\n' from input to NULL

alternate way of using strsep: while(cmd[i++] = strsep( &s, " " ))

11/28/16
SoftDev:

Aim: After being framed, you might need to take a REST

Tips for using frameworks:
     Many files have .min equivalents, which contains the same code without any extra formatting.

     jquery is a popular javascript library used in many frameworks.

     The order in which you include javascript is important. They are loaded sequentially.

ex:
	<script src="jquery-3.1.1.js"></script>


Javascript in <head> or at the end of <body>?
	   Yet another programmer holy war

	   Advantages to head:
	   	      scripts will definitely be loaded bofore anything else, so page elements that need scripting will be attached.

	   Disadvantages to head:
	   	      scripts will take longer to load (not compiled)

	   Advantages to end of body:
	   	      Page content loads much faster

	   Disadvantages to end of body:
	   	   Page might look fully loaded while scripts will continue to be downloaded.

REST API:

     Application Program Interface.

     Way to interact with other existing program.

     published set of protocols that can be used to have your program with others.

     REST (Representational State Transfer)
     	  APIs that transmit data back after receiving an http[s] request.
	  Returned data can be in various formats, most common are html, xml, json.

JSON (Javascript object notation)
     Standard way of representating data. Can be easily translated into a python dictionary.

ex:
	https://api.nasa.gov/planetary/apod?api_key=....

	takes one variable (api key) in the url


11/29/16
Systems:

Aim: Sharing is caring!

Shared memory - <sys/shm.h>, <sys/ipc.h>, <sys/types.h>
       A segment of heap memory that can be accesssed by multiple processes.

       Shared memory is accessed via some key that is known by any process that needs to access it.

       Shared memory does not get released when a program exits.

       5 shared memory operations:
       	 Create the segment (once)
	 Access the segment (once per process)
	 Attach the segment to a variable (once per process)
	 Detach the segment from a variable (once per process)
	 Remove the segment (once)

Shared memory is not about child-parent relations, can be accessed by any process.

shmget
	Create or access a shared memory segment.

	Returns a shared memory descriptor (similar to a file descriptor), or -1 if it fails.

	shmget( key, size, flags )

		key
			unique identifier for the shared memory segment ( like a file name ).

		size
			How much memory to request

		flags
			includes permissions for the segment.

			combine with bitwise or

			IPC_CREAT: create the segment
				   If segment is new, will set value to all 0s.

			IPC_EXCL: fail if the segment already exists and IPC_CREAT is on


ex:
	int sd = shmget( 24601, 4, IPC_CREAT | 0644 );

shmat
	Attach a shared memory segment to a variable

	Returns a pointer to the segment, or -1 (errno).

	shmat( descriptor, address, flags )
	       descriptor
			the return value of shmget

		address
			if 0, the OS will provide the appropriate address

		flags
			Usually 0, there is one useful flag

			SHM_RDONLY: makes the memory read only


SoftDev:

Aim: Web crawling pythons

Making and parsing a REST call in python

       urlib2
		Library to handle urls

		.urlopen
			u = urllib2.urlopen(<URL>)

			Open a url to be read by your program

			Just opens url, doesn't get data yet.

		.geturl()
			returns the atual url (in case of redirects)

		.info()
			returns the http/s header information

		.read()
			returns the contents of the target webpage, as a string
				e.g., if image file, returns bytes of the image.



json
	Library to work with json data

	.loads(<STRING>)
		d = json.loads(<STRING>)
		Turns a json object string into a dictionary

	.dumps(<DICTIONARY>)
		Turns a python dictionary into a json object string


11/30/16
Systems:

Aim: Memes

command: ipcs (interprocess communications) -> shows shared memories

shmdt
	Detach a variable from a shared memory segment

	Returns 0 upon success or -1 upon failure

	shmdt( pointer )
	       pointer
		The address used to access the segment

	example
		shmdt( P )

Detaching revokes access -> gives segmentation fault if still accessign after detach.

shmctl
	Perform operations on the shared memory segment

	can remove segment operation

	Each shared memory segment has metadata that can stored in a struct (shmid_ds)
	Some of that data stored: last acces, size, pid of creator, pid of ast modification.

	shmctl( descriptor, command, buffer )

		descriptor
			return value of shmget

		commands:
			IPC_RMID: remove a shared memory segment

			IPC_STAT: populate the buffer (struct shmid_ds) with information

			IPC_SET: set some of the information for the segment to the info in buffer

		example:
		struct shmid_ds d;
		shmctl( sd, IPC_RMID, &d )



ftok - <sys/ipc.h>

     Generate a key useful for IPC functions

     ftok( path, x )

     	   path
		a path to some file, the file must be accessible by the program

	   x
		an int used to generate the key

	   The same path and x will always generate the same key
	   Combines file + int, pseudo-random


     sd = shmget( ftok("dir/file", 12), 1024, IPC_CREAT | 0664 );


12/5/16
Systems

Aim: How do we flag down a resource?

System V IPC != POSIX.

Semaphore: keeps processes from colliding when interacting w/ same memory.

	   created by Edsger Dijkstra

	   IPC construct used to control access to a shared resource (like a file or shared memory).

	   Essentially, a semaphore is a counter that represents how many processes can access a resource at any given time.

	   		If a semaphore has a value of 3, then it can have 3 active "users".

			If a semaphore has a value of 0, then it is unavailable.

			A mutex is a semaphore with a value of 1.

	Most semaphore operations are "atomic," meaning they will not be split up into multiple processor instructions.
	     Create a semophore
	     Set up initial value
	     	 Up(S)/V(S)
			Release the semaphore to signal you are done with its associated resource

			pseudocode: S++

		Down(S)/P(S)
			Attempt to take the semaphore.

			If the semaphore is 0, wait for it to be available.

		pseudocode:
			While(S==0)
				block (when a program halts operation)
			S--

		Remove a semaphore (when done)

Semaphores in C - <sys/types.h> <sys/ipc.h> <sys/sem.h>

	   semget
		Create/get access to a semaphore.
		Not the same as Ups(S), it does not modify the semaphore.

		Returns a semaphore descriotpr or -1 (errno).

		semget( <KEY>, <AMOUNT>, <FLAGS> )
			KEY = unique identifier (use ftok)

			Aount = semaphore are stored as sets with potentially many semaphores together. This parameter sets the # of seiphores tocreate/get.

			FLAGS = includes permissions for the semaphore.
			      combine with bitwise or IPC_CREAT = create the semaphore and set value to 0, IPC_ESCL = fail if IPC_CREAT is on.

ex:
	int key = ftok( "makefile", 57 );
	int semed = semget( key, 1, IPC_CREAT | 0644 ); -> 544 = read+access (r + A).



12/6/16
Systems

Aim: What's a semaphore? - To control resources!

With a union, you're only supposed to use one of the elements, because they're all stored at the same spot.
This makes it useful when you want to store something that could be one of several types.
A struct, on the other hand, has a separate memory location for each of its elements and they all can be used at once.

Semaphore code
	  semctl - <sys/types.h> <sys/ipc.h> <sys/sem.h>

	  	 control the semaphore, including:
		 	 set the semaphore value
			 Remove the semaphore
			 Get the current value
			 Get information about the semaphore

		semctl( <DECRIPTION>, <INDEX>, <OPERATION>, <DATA> )

			Decription
				return value of semget

			Index
				The index of the semaphore you want to control in the semaphore
				set identified by the descriptor for a single semaphore set, 0

			Operation
				One of the following constants (there are others as well)

				IPC_RMID: remove the semaphore

				SETVAL: Set the value (requires DATA)

				SETALL: Set the value of every semaphore in the set (requires DATA)

				GETVAL: returns value

				IPC_STAT: Populate buffer with information about the semaphore (requires DATA)


			Data
				Variable for setting/storing information about the semaphore
				(data type: union semun)

				you have to declare this union in your main c file on linux machines

				union semun {
				      int val;
				      struct semid_ds *buf;
				      unsigned short *array;
				      struct seminfo *_buf;
				};

					val: used to set initial value
					buf: buffer for IPC_STAT


ex:
	int semid;
	int key = ftok( "makefile", 22 );

	semid = semget( key, 1, IPC_CREAT | 0644 );

	union semun su;
	su.val = 1;
	int i = semctl( semid, 0, SETVAL, su );
	i = semctl( semid, 0, GETVAL ); //doesnt need unon semun su
	i = semctl( semid, 0, IPC_RMID );


semop
	perform semaphore operations (like Up/Down)

	all operations performed via semop are atomic!

	semop( <DESCRIPTOR>, <OPERATION>, <AMOUNT> )
	       amount
			the amount of semaphores you want to operate on in the semaphore set

	       operation
			a pointer to a struct sembuf value

			  struct sembuf {
			  	 short sem_op;
				 short sem_num;
				 short sem_flag;
				 };

			sem_num
				the index of the semaphore you want to work on

			sem_op
				-1: Down(S)
				1: Up(S)

				any -/+ number will work, you will be requesting/releasing that value from the semaphore.

				0: Wait until the semaphore reaches 0.

			sem_flag
				Provide further options

				SEM_UNDO: Allow the OS to undo the given operation
					  Useful in the event that a program exits before it could relase a semaphore.

				IPC_NOWAIT: Instead of waiting for the semaphore to be available, return an error.



12/7/16
Systems

Aim: What goes up really should come down.

ex:
	srand( time(NULL) )
	int x = random() % 10;
	int semid = semget( ftok("makefile", 22), 1, 0 );
	printf("[%d] Before access, %d\n", getpid(), x );

	struct sembuf sb;
	sb.sem_num = 0;
	sb.sem_flg = SEM_UNDO;
	sb.semop = -1;

	semop( semid, &sb, 1 );
	prinf("[%d] I'm in!\n", getpid());

	sleep(x);

	sb.sem_op = 1;
	semop( semid, &sb, 1 );

	printf("[%d] I'm done!", getpid());

//processes all have to wait 8 seconds.


12/12/16
Systems

Aim: Ceci n'est pas une pipe
(This is not a pipe; this is a picture of a pipe)

ex:
	struct stat sb;
	stat( "story.txt", &sb );
	int size = sb.st_size;
	char * s = (char*) malloc(size);
	int fd = open( "story.txt.", ...


Pipe
	A conduit between 2 separate processes. (Not a network direction)
	Pipes have 2 ends, a read end and a write end.
	Pipes are unidirectional (a single pipe must be either read or write only in a process)

	You can transfer any data you like through a pipe using read/write

	Unnamed pipes have no external identification (pipes act like files)
		- limited to child-parent situations (childs inherit)


pipe - <unistd.h>
     Create an unnamed pipe

     Returns 0 if the pipe was created, -1 if not

     Opens both ends of the pipe as files.

     pipe( int descriptrors[2] )
     	   descriptors
		Array that will contain the descriptors for each end of the pipe.

ex:
		int fds[2];
		char s[20];

		pipe( fds );

		int fork();
		if( f = 0 ) {
		    close( fd[1] );
		    read( fds[0], s, sizeof(s) );
		    printf( "[child] recieved: %s\n", s );
		}
		else {
		     close( fd[0] );
		     sleep(3);
		     write( fds[1], "hello child", 12 );
		}

12/13/16
Systems

Aim: A pipe by any other name...

Pipe: flipping decriptors DOESN'T work!

Name pipes
     A.K.A. FIFOs

     Same as unnamed pipes except FIFOs have a name that can be used to identify them via different programs.

     Like unnamed pipes, FIFOs are unidirectional.


     mkfifo
	shell command to make a FIFO

	$mkfifo <pipe name>

pipe: prw-r--r--

multiple reading / writing in pipes: gives confusion on what you are recieving.
	 (cat pipe)/(cat > pipe)

after connection is established, removing pipe does nothing (conduit is created already)

      mkfifo - <sys/types.h> <sys/stat.h>
      	     c funciton to create a FIFO

	     Returns 0 on success and -1 on failure

	     Once created, the FIFO acts like a regular file, and we can use open, read, write and close on it.

	     mkfifo( <name>, <permissions> )

	     FIFOs will block on open until both ends of the pipe have a connection.


SoftDev

Aim: Learning to write in script

javascript
	Programming language originally designed to augment html and to be run locally on a web browser.

	No direct relationship with java, though both have similar syntax.

	Dynamically typed - variable types are rpvoded at runtime (like python).

	Most development will be done through a web browser's console.

	console.log()
		There is no built in i/o. console.log() will display a string to the console.

		"undefined" means that the variable is undefined

	C-style syntax

	Variable basics: var (decimals -> doubles)
		 can also be a number, string, arrays/lists, and dictionary (object)
		 booleans: true/false (lowercase)

Document Object Model (DOM)

	 javascript derives most of its utility through being able to interact with html and xml documents.

	 The DOM is an API for interacting with html. It provides a structure that we can interact with and can be manipulated by functions.

	 Pages are represented as trees.

Selecting HTML elements
	  document.getElementById(<ID>) -> will return the first one
	  document.getElementsByTagName(<TAG>) -> list
	  document.getElementsByClassName(<CLASS>) -> list



12/14/16
Systems

Aim: Always remember to tip your servers.


Server/Client Program Paradigms
	      Handshake
		A prodcedure to ensure that a connection has been established

		Both ends of the connection must verify that they can send and recieve data to and from each other.


Basic handshake procedure:
      1) Server creates a FIFO (well known pipe).
      2) Server wait for a connection (use open)

      3) client, create "private" FIFO
      4) Client connects to server and sends the private IFO name.

      5) Client waits for a message from the server.
      6) Server recieves a passage and can remove WKP (well known pipre).

      7) Server connects to silent FIFO, sends a initial ackonowledgement mesage.

      8) Client receives server's message, removes private (connection is there).

Softdev

Aim: Functional code

     	document.getElementById(<ID>) -> will return the first one
	document.getElementsByTagName(<TAG>) -> list
	document.getElementsByClassName(<CLASS>) -> list


	They get nodes and display it toString();

Manipulating DOM elements

	list.remove() removes the node.
	.innerHTML -> changes content between the tags
	document.createElement( <HTML TAG NAME> ) -> adds a node
	.appendChild( <ELEMENt> )
	.setAttribute( <NAME>, <VALUE> )
	.getAttribute( <NAME> )
	.addEventListener( <EVENT>, <FUNCTION> ) -> every node can have a listener attached to it

Functions in javascript!

	  javascript is functional. Like Scheme (Racket)!

	  Functions are first class objects that can be used like any other value.

	  like lamba (fxn that creates fxn)
	       function() creates anonymous functions

	       var foo = function() { console.log("yo"); }; -> function() is a statement

	  b.addEventListener( "click", function() { alert("ANNOYING!"); } ); -> must have a function value (can't be just alert())
 -> Thats because functions have return values, alert as second argument -> means call alert -> put return value as event listener (alert has no return, so attached no function (undefined))

The other example, the function "returns" a function

b.addEventListener( "click", function(e) { console.log(e); } ); -> argument would be the event listener

var f = function(e) {
    console.log(e);
    console.log(this); -> gives DOM element (e.g. returns <button id="b">... )
};
b.addEventListener( "click", f ); -> f is bound to a function (doesn't need to list parameters)

12/16/16
Systems

[SERVER] WKP Created / [CLIENT] fifo created: pid()
[SERVER](/[CLIENT]) connection attempt/connetected to WKP
[SERVER] recieved: pid()
[SERVER] recieved: thank you

...

can fork server (server =  queen bee)
