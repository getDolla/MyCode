9/28/16
SoftDev:

Aim: Requesting assistance

request object
	stores information about incoming requests.
ex:
from flask import Flask, render_template, request

ex (from flasktest.py):
print request.headers
return render_template( "form.html" )

prints:
Referer: http://127.0.0.1:5000/
Content-Length: 
User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:48.0) Gecko/20100101 Firefox/48.0
Connection: keep-alive
Host: 127.0.0.1:5000
Upgrade-Insecure-Requests: 1
Cache-Control: max-age=0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Content-Type: 
Accept-Encoding: gzip, deflate

HTML:
<form action="/msg/">
<textarea name = "message" rows = "6" cols= "40"></textarea>
Python:
@app.route( "/msg/" )
def auth():
    print request.headers
    print request.args
    print request.args["message"]
    return "You good"


9/29/16
Systems:

Aim: Make so

Make
	Create compiling instructions and setup dependencies
	Standard name for the file is the makefile.

	Syntax:
		<target><dependencies>
		TAB<rules>


	strtest: stringy.c
		 gcc stringy.c

	clean:
		rm *~


	make clean would remove all emacs save files
	(files with ~ at the end of filename).


SoftDev:

Aim: Dont forget to include POSTage
DN: Open up yesterday's flask app

request.headers
	HTML headers sent from borwser
request.method
	the request method (GET/POST)
request.args
	the arguments in a query string from a GET request
request.form
	the arguments sent in a POST request
request.args and request.form are immutable dictionaries.

the u in the dictionary is unicode (string)

9/30/16
SoftDev:

Aim: Always Serve Your Passwords With A Side of Hashbrowns

Hash function
     function designed to take in an arbitrary amount of data and return a fixed
      size sequence of bits called a "hash digest" or simply, hash.

      Hash digests are useful for storing certain kinds of sensitive information.

Creating a had digest in python:
	 hashlib
		python module for generating has digests with different
		algorithms

		ex:
			md5 (bad), sha1, sha224, sha256, sha384, and sha512 (spits more bytes)

		ex:
		import hashlib
		hashlib.md5("12345")
		hashlib.md5("12345").digest() -> returns as string as attempted
		ASCII (looks messy w/ "\x")

		hashlib.md5("12345").hexdigest() -> gives savable string as hex

		hashlib.sha1("12345").hexdigest() -> longer
		hashlib.sha512("12345").hexdigest() -> much longer hex values

10/5/16
Systems:

Aim: If these files won't behave, we'll have to separate them!

DN: Demo.

crazy one line version of strlen:
int len(char *s) {
    return *s?1+len(*++s):0;
}

dw strcat:
char * dwstrcat( char * s1, char *s2 ) {
     char * p;
     p = s1 + len( s1 );
     dw strcpy(p);
     }

separate compilation:
	 You can combine multiple c files into a c program by
	 including them all in one gcc command.
	     ex:
		gcc test.c string.c foo.c woohoo.c
	 
	 You cannot have duplicate function or global variable names
	 across these files.
	 	ex: main()


one solution: make file w/o main
    ex: #include "dwstring.h"
    	void main() { ... }


	$gcc dwstrtest.c dwstring.c

SoftDev:

Aim: C is for Cookie, but Sessions are Secure

DN: Demo.

How to keep track who is logged in:

Cookies are files that websites will save to your web browser 
to store information on a local machine.

Useful for keeping track of persistent information like login credentials.

They have been around for a long time (not new).

A session is a securely signed cookie. They are encryted and cannot be modified
by the local machine.

A session object works exactly like a dictionary:
  add data to a session:
  session[KEY] = DATA
  	       ex: session['user'] = request.form('user')
 
  remove data from a session:
  session.pop(KEY)
	ex: session.pop('user')

  In order to encrypt session, need a private key in our app:
     APP.secret_key = <RANDOM STRING>

     		    get random data: os.urandom(32)
		    returns 32 random bits of data as string.

10/6/16
Systems:

Aim: malloc & free: The dynamic duo!

     gcc -c dwstring.c main.c  = compile but not make it executable

     -> dwstring.o main.o

     gcc dwstring.o main.o

     -> a.out


.o files can be linked together with .c files through gcc

gcc -o specify name of executable file

gcc would try to make file executable, gives error if "main" is missing.


void * malloc(int x)
	   memory is not initialized (allocates x bytes of memory from the heap)
	   generates generic pointer return, able to typecaste to appropriate
	   pointer.

free(void *ptr)
     releases previously allocated memory. 

void * calloc(int n, int x)
     allocates n * x bytes of memory
     ensures each bit = 0
     generates generic pointer return, able to typecaste to appropriate pointer.

void * realloc(void *ptr, int x)
     takes a pointer and changes the amount of memory allocated to given block

     ptr must be a pointer to the beginning of an allocated block of memory, but it does not have to be the original pointer.


SoftDev:

Aim: Url binding is the art of redirection

     app.secret_key = os.urandom(32)
     that could log out all of the users when app is restarted.

     ex:
     print url_for( "login" ) 
     uses associated function to build correct url
     
     redirect
     Flask fxn that will redirect a call to one route to a different response
     used in combination with url_for
     	  ex:
		redirect( url_for('login') )

10/7/16
Systems:

Aim: Structural Programing

void *
     the dynamic memory functions deal in arbitrary blocks of memory.
     There is no regular type associated with the block.

     void * is considered to be a pointer to a 1 byte block of memory,
     so pointer arithmetic will be based on 1.

ex:
  int *p;
  p = malloc( 5 * sizeof(int) ); //same as calloc( 5, sizeof(int) )

  p[0] = 2;
  printf( "p[0]: %d\n", 0[p] );

ex:
  int *ip;
  ip = (int*)malloc( 20 * sizeof(int) );


Struct
	A collection of values in a single data type
	struct { int a; char x; } s; sizeof(s) -> 8 (does units of 8 bytes)
	|-----------------------|
	  s is a type that has an int and char

	  here, s is a variable of type struct { int a; char x; }


	struct foo { int a; char x; };
	       in this example, foo is a prototype for this kind of struct
	       to be used later.

	struct foo s;
	we use the . oparator to access values in a struct:
	   ex:
		s.a

	We use the . operator to access a value iside a struct
	   s.a = 10;
	   s.x = '@';

	   . binds before *
	     to access data from a struct pointer you can either:
	     	struct foo *p;
		p = &s;
		(*p).x;
			or...
		p->x;

10/11/16
Systems:

Aim: Get Dem Bugs

What is wrong with this fxn?
struct node * insert_front( struct node * n, int i ) {
       struct node new;

       new.i = i;
       new.next = n;

       return &new;

}
The fxn is reasonably okay, but it is stack memory (new and its variables will be popped).
The only time memory is allocated dynamically is by using malloc, calloc, ect.

Typedef
	provide a new name for an existing data type
	typedef <real type> <new name>;

	ex:
		typedef unsigned long size_t;
		size_t x = 139; //really an unsigned long

		typeof short[10] list;
		list a;
		typeof char * String;

		typedef struct foo { int a; char x; } bar;


gdb (GNU Debugger)
    allows you to get detailed information about a program while it is running.

    ex: gdb a.out

    quit = quit gdb
    list = lines of code around error

    ex: break 10 = set a breakpoint at line 10

    print <VAR> = prints a variable

    backtrace = show the currect stack


valgrind
	debugging tools specializing in memory values.
	
	
	valgrind --leak-check=yes ./a.out
		 checks memory leaks


9/13/16
Softdev:

Aim: All your data are belong to us.

Relational database
	   Database that stores information as a collection of tables.

	   Field: column data in a RDB
	   Record: row in a RDB
	   Data can be linked between tables based on field values.

ex:
Students
name:	| id:
-------------------
amy	| 0
reo	| 1
emma	| 3


Class
name:	| student id:	| grade
------------------------------------
softdev	| 0		| 100
softdev	| 1		| 100


the id is related to the id in the students table


SQL (Structured Query Language)
    Standard language designed to work with relational databases.
    
    Is used for many major db programs, though the implementations may not
    (mostly are not) compatible.

    MySQL, PostgreSQL, SQLite, Oracle are different SQL implementations.

SQLite
	SQL implementation that relies entirely on functions calls in the parent 
	program. There is no database server.

	All database information is stored in a single file.

	Data is dymanically typed as values are inserted into a table.

Basic SQLite Operations
      CREATE TABLE
      	     Add a table to a database
	     CREATE TABLE <name> (<column name> <data type>, ... )
	     	    The data type will help to convert entered values to a 
		    suggested type.

		    TEXT, INTEGER, REAL, NUMERIC, BLOB
		    	  NUMERIC will default to an integer, but can be a float.
			  
			  BLOB means no suggested type.

ex:
	$ sqlite3 school.db
	...>CREATE TABLE students (name TEXT,...);
	.tables = show the tables
	INSERT INTO students VALUES ("amy", 0);
	INSERT INTO classes VALUES ("softdev", 0, NULL ); 


	Columns can be given a PRIMARY KEY attribute.
	denoting that every entry in that column is unique and cannot be NULL

	Columns can be given NOT NULL attribute, denoting that no entry can be NULL.
	INSET INTO
	      Insert a record into a table
	      INSERT INTO <name> VALUES ( <field 1>, <field 2> ... )
	      	     Will add a record to a table matching the values to the columns in order.
	
	NULL can be used in any entry.

	SELECT * FROM <name>; = select everything from a table

SQLITE Shell commands
       .quit
       .tables
       .header on|off
       .mode column|csv|list|html|insert|line|tabs

10/17/16
SoftDev:

Aim: sqlite, the low-fat alternative to SQL

python sqlite module
        import sqlite3

        connect
		open/create an sqlite database.
		
    		If the database does not exists, create it.
		   db = sqlite3.connect(<db name>).

        cursor
		Create a database cursor object that will allow you to perform
		operations of the databse.

		c = db.cursor()

        execute
		cursor method to perform the provided SQL operation, given as a
		string.
		
		c.execute( <SQL statement> )

	commit
		database method to save changes to the db

		db.commit()

	db.close()


	formatting strings in python:
		   '(' + x + ', ' + y + ') is a point'
		       =
		   '(%d, %d) is a point'%(x, y)


		   %d = decimal integer
		   %f = floating point
		   %s = string

	ex:
	command = 'INSERT INTO students VALUES ("%s", %d, %d'%(students['name'], ...

SQL SELECT Statement
    Used to get data from a database
    Creates a results table based on the query
    SELECT <column 1>, ... FROM <table 1>, ...;
    	   Will return a new table containing only the requested columns from the requested 
	   tables.

	   ex:
		SELECT name FROM students;
		SELECT * FROM students; -> gives everything from students
		SELECT name, id, code FROM students, courses; -> needs to specify
		    solution:  ->  students.id
		
10/18/16
Systems:

Aim: C, the ultimate hipster, using # decades before it was cool

ex:
	#include "link_list.h"
	->if you include 2 .h files, where one .h file includes another .h file,
	the .h file would be included twice. That is problematic.

#
	used to provide preprocessor instructions
	these directives are handled before the compler really kicks in.
	NOT regular c syntax
	gcc basically goes and copies content of the header file to where "include" is

	#include <library> or "LIBRARY"
		 link libraries to your code.

	#define <NAME> <VALUE>
		"find and replace" all occurances of NAME with VALUE

		ex:
			#define TRUE 1
				TRUE is not a variable, and doesn't get replaced in a string.

		macros:
			#define SQUARE(x) x*x (not a fxn)
			...
			int y = SQUARE(9); -> int y = 9 * 9;
			    DOESN'T COMPUTE 9*9!!

		conditional statement:
		#ifndef (if not defined) <IDENTIFIER>
		<CODE: deal with whatever is in here>
		#endif

		if the identifier has to be defined ignore all the code up until the
		endif statement.

		ex:
			#ifndef LINK_LIST_H
			#define LINK_LIST_H
			...

		also:
			#define FOO 5
			a[FOO] would be fine since FOO would be replaced.

	rand(), srand(int), sranddev()
		srand(int) = sets a seed, can be used as srand( time(t sec since epoch) )
			   time(NULL) needs #include <time.h>
		sranddev() = seed rand() with random number
			   (linux has a "file" that generates random values)
		rand() = random number generator

SoftDev:

Aim: WHERE did I put that data?

WHERE
	allows you to put restirctions on the results of a SELECT statement.
	
	ex:
		SELECT * FROM courses WHERE mark < 65;

		can use single = sign for equality test

	ex:
		select name, students.id, courses.id, code, mark from students, courses where students.id = courses.id and mark > 70;
		name        id          id          code        mark      
		----------  ----------  ----------  ----------  ----------
		kruder      1           1           systems     75        
		kruder      1           1           ceramics    99        
		dorfmeiste  2           2           softdev     75        
		dorfmeiste  2           2           ceramics    98        
		sasha       3           3           greatbooks  85        
		digweed     4           4           softdev     75        
		bassnectar  6           6           ceramics    90        
		bassnectar  6           6           systems     90        
		bassnectar  6           6           softdev     99        
		TOKiMONSTA  7           7           systems     88        
		TOKiMONSTA  7           7           softdev     85        
		jphlip      8           8           systems     98        
		alison      10          10          systems     85        
		alison      10          10          softdev     80

  
10/19/16
Systems:

Aim: A bit of operators

>> and << are binary operators.

int i = 30;
i = i>>2;
    i -> 8 (shifted values 2 bits to the "right", and added 2 0s in the front)
i = i<<2;
    i -> 28 (NOT 30)

~ negation
  flips every bit

  ex:
	00001 -> 11110

| or, & and
  ex:
	a | b -> 10010 | 01010 -> 11010
	a & b -> 10010 & 01010 -> 00010
    
    perform or/and for each pair of bits in (a, b)

^ xor
  ex:
	a ^ b

	perform xor for each pair of bits in (a, b)



10/21/16
Systems:

Aim: File this under useful information.

File permissions:
     read, write, and execute

     3 digit binary #s or 1-digit octal
     100 -> read only
     111 -> read, write, and execute


     3 permission areas: owner/user, group, other
     3-digit octal number
     	     ex: 644 -> user: read + write, group+other: read
	     default: -rw-r--r-- (644)

	     directories are also files (that contain a list of files they contain)
	     (look = read, add files = write, cd into directory = execute)
	     your id is in the metadata (data about data) in the file.


     File table:
     	  A list of all the files that is used by a program while it is running.
	  Contains basic info such as location and size.

	  has a limited size, which is a power of 2 and commonly 256 files (not bytes), and
	  getdtablesize() will return this size.

	  each file is given an integer index (starts at 0) and referred to as file descriptor
	  3 files are always open in the table:
	    	  0 or STDIN_FILENO: stdin
		  1 or STDOUT_FILENO: stdout
		  2 or STDERR_FILENO: stderr (standard error)
		  (they are links)

10/24/16
Aim: Opening up a world of possibilities

open/close
	-open: takes path string, what type of access (ex append) and optionally permission. returns int of -1 if unsuccessful.
	-close: closes file associated with handle and returns 0 if unsuccessful and -1 if error.

read/write
	-read: read( int rd, void *buf, int count )
	       read operation that attempts to read count bytes from buf associated with rd.
	-write: writes count bytes from buf to the file associated with rd.


open - <fcntl.h>
     add a file to the file table and returns its file descriptor

     if fails, -1 is returned, extra error infrmation can be found in errno.

     	errno is an int variable that can be found in <errno.h>, using strerror (in string.h)
	on errno will return a string decription of the error

	open( <PATH>, <FLAGS>, <MODE> )

	mode
		only used when creating a file. set the new files permissions using a 3 digit octal # (have a leading 0)

	ex:

	fd = open( "tester", O_RDONLY ); -> 3 if successful (0, 1, and 2 are taken)
	printf( "error: %d - %s", errno strerror(errno) );

	flags
		Determine what you plan to do with the file.
			 O_RDONLY
			 O_WRONLY
			 O_RDWR
			 O_APPEND
			 O_TRUNC
			 O_CREAT (create)
			 O_EXCL: (exclusive) only works when combined with O_CREAT, will return error if file exist

		
Each flag is a number, to combine flags we use bitwise or
     O_WRONLY = 1
     O_APPEND = 8
     O_WRONGLY | O_APPEND = 00001001


close - <unistd.h>
      remove a file from the file table (0 if successful)

      close( <FILE DESCRIPTION> );

10/24/16
Systems:

Aim:

umask - <sys/stat.h>
      set the file creation perission mask
      By default, created files are not given the exact permissions provided in the mode argument to open. Some permissions are automatically shut off. (ex: 0666 != rw-r--r--)

      Umask is applied by using bitwise negation on the mask, then bitwise and and-ing it to the mode
      new_permissions = ~umask & mode

      default umask = 0022.


So here, we get:
   umask:  000 010 010

   ~umask: 111 101 101
   & mode: 110 110 110
   -------------------
   result: 110 100 100

umask( <MASK> )
       ex: umask( 0000 ); -> everything is on
       	   umask( 0111 ); -> no execute permission

Read = take data from storage and dump into memory
read - <unistd.h>
     read( <file descriptor>, <buffer>, <amount> )
     read( fd, buff, n )

     same errno stuff ( -1, ect. ) as open
     read n bytes from the fd's file and put that data into buff

     returns the number of bytes actually read (if successful).
     buffer must be a pointer (doesn't naturally have to be a string).
     	    	 -can read integers if the file has actual numbers


write - <unistd.h>
      "twin" of read
      write n bytes from buff into fd's file

      returns the number of bytes actually written. Same errno stuff as open/read.
      buffer must be a pointer.


10/27/16
Systems:

Aim: Seek and ye shall find

-write raw byte data into txt file
       reads the int one byte at a time and attempts to read it as ASCII

lseek - <unistd.h>
      Set the current position in an open file
      lseek( <FILE DESCRIPTOR>, <OFFSET>, <WHENCE> )

      offset = # of bytes (can be negative)
      whence = where to measure offset from
      	     SEEK_SET
		offset is evaluated from the beginning of the file

	     SEEK_CUR
		offset is relative to the current position in the file

	     SEEK_END
		offset is evaluated from the end of the file

	returns the # of bytes the current position is from the beginning of the file

ex:
	int b = write(fd, r, sizeof(r) );

	lseek( fd, 0, SEEK_SET )
	int x;
	read( fd, &x, sizeof(int) );
	printf( "x: %d\n", x );
	printf( "b: %d\n", b );


	
10/28/16
Systems:

octal permission: ex: 100644
      1 is a regular file, 4 is a directory


Softdev:

Stuff we can add:
being_edited = boolean when user in middle of editing story

11/1/16
Systems:

Aim: Where fo compsci priests live? - In directory!

sprintf:
	print formated string into a string.

calloc guarantees terminanting null.

convert octal to string rwx:

perms[0] = (mode & 0b11000000) >> 6;
perms[1] = (mode & 0b111000) >> 3;
perms[2] = (mode & 0b111);

or:
110 100 100

if( mode & 256 )
    perm_string[0] = 'r';


Directories:
	A *nix directory is a file containing the names of the files within the 
directory along with basic information like file type.

	Moving files into/out of a directory means changing the directory file. 
not actually moving any data.

opendir - <dirent.h>
	open a directory file.

	This will not change the cwd, it only allows your program to read the 
contents of the directory file.

	 opendir( <PATH );

	 returns a pointer to a directory stream (DIR *)

closedir - <dirent.h>
	 closes the directory stream and frees the pointer associated with it.

	 closedir( <DIRECTORY STREAM> )

readdir - <dirent.h>

	readdir( <DIRECTORY STREAM> )

	Returns a pointer to the next entry in a directory stream, or NULL if all entries have already been returned.

	struct dirent - <sys/types.h>
	       Directory struct that contains the information stored in a directory.

SoftDev:

Aim: Extending your template knowledge.

Extending HTML templates
	  any template can be inherited by others
	  To extend a template: {% extends "<TEMPLATE>" %}

	  You can define sections to override inside.
	  ex: (content is a name)

	  {% block content %}

	  {% endblock %}
	  
Note about directories (Systems):
	// . refers to directory itself and .. refers to the parent directory


11/3/16
Systems:

Aim: Input? fgets about it!

stat provides metadata (doesnt open file)

getcwd - <unistd.h>
       get the current working directory (cwd) of a program

       getcwd( <STRING BUFFER>, <SIZE> )
       	       copies the path to the cwd into the buffer argument (char * )
	       copies at most SIZE characters of the path

       ex:
       char path[100];
       path[99] = 0;
       getcwd(path, 99);
       printf( "current directory: %s\n", path ); -> gets absolute path

chdir - <unistd.h>
      change the working directory of a program

      chdir( <PATH> )
      	     returns 0 if successful, -1 (errmo) if not
	     keep track of file paths when using chdir!
      
      chdir( ".." );
      getcwd(path, 99);
      printf( "current directory: %s\n", path ); -> now prints parent directory


Command Line Arguments:

	int main( int argc, char *argv[] )
	program name is considered the first command line argument

	argc
		number of command line arguments

	argv
		array of command line arguments


	ex:
	while( argc ) {
	       argc--;
	       printf( "%d: %s\n", argc, argv[argc] );
	}	

scanf - <stdio.h>
	scanf( <FORMAT STRING>, <VAR 1>, <VAR 2>, ... );
	
	ex:
	int i; float f;
	scanf( "%d-%f", &i, &f );


11/4/16
Systems:

Aim: Sending mixed signals

fgets - <stdio.h>
    Read in from a file stream and store it in a string
    fgets(<DESTINATION>, <BYTES>,< FILE POINTER>)

    File pointer
        FILE * type, more complex than a file descriptor
        stdin is a FILE * variable

    Stops at newline, EOF, or the byte limit.
    If applicable, keeps the newline character as part of the string, appends NULL after

Signals
    Limited way of sending information to a process.
    kill
        Command line utility to send a signal to a process
        $ kill <PID>
            Sends signal 15 (SIGTERM) to PID
	    
the command "ps" shows a list of running processes that were run from a terminal
	"ps -ax" shows ALL processes
	
PID is process id
All process information can be found in /proc/<PID>

11/7/16
Systems:

Aim: Are your processes running? - Then you should go out and catch them!


Processes
	Every running program is a process. A process can create subprocesses, 
	but these are no different from regular processes.

	A processor can handle 1 process per cycle (per core). "Multitasking" 
	appears to happen because the processor switches between all the active
	processes quickly.

pid
	Every process has a unique identifie called the pid.
	pid 1 is the init process
	each entry in the /proc directory is a current pid.

getpid() - <unistd.h>
	 returns current process' pid

getppid() - <unistd.h>
	 returns current process' parent pid

Signals
	Limited way of sending information to a process.

	kill
		command line utility to send a signal to a process
		
		$kill <PID>
		      sends signal 15 (SIGTERM) to PID

		$kill -9 <PID> will give a different signal
		      (Killed: 9 is different from the default Terminated: 15)

		killall [-<SIGNAL>] <PROCESS>
			sends sigterm (or signal if provided) to all processes 
			with process as the name

Signal handling in c programs <signal.h>
       kill
	kill(<PID>, <SIGNAL>)
		    returns 0 on success or -1 (errno) on failure.

Sighandler
	To intercept signals in a c program you must create a signal handling 
	function.

	Some signals (like SIGKILL) cannot be caught.
	
	static void sighandler( int signo )
		Must be static, muct be void, must take a single int parameter.
		static: the function can only be called from within the file it
		is defined.

	in main attatch:
	   signal( SIGINT, sighandler );

sleep(1); wait 1 second before "spamming"


11/10/16
Systems:

Aim: What the fork?

fork: "forks" a new process (make a sub (new) process)
(ex: bash: command -> subprocess ->bash)

The child process runs on its own. They don't share information and 
can have some intercations (signals).


fork() - <unistd.h>
       Creates a separate process based on the current one, the new process is 
       called the child, the original is the parent.

       The child process is a duplicate of the parent process. All parts of the 
       parent process are copied, including stack and heap memory, and 
       the file table.

       Returns 0 to the child and the child's pid to the parent or -1 (errno).
       (the child gets a return value (0) from fork and the parent will get the 
       pid of the child or -1 (if fails-no child).)

       If a parent process ends before the child, the child's new parent pid is 1.


       ex:
       int f;
       printf(pid)
       f = fork();
       printf(pid) -> now run by 2 processes (parent does not always execute 1st (more like
       child finishes, then parent comes back))
       if the parent finishes its function, and the child has not, the ppid would print 1.

       look at return value of fork to assign different tasks.


11/15/16
Systems:

Aim: Wait for it...

f = fork();
if( f == 0 )
    printf("I'm a child: %d, parent: %d\n", getpid(), getppid());
else
    printf("I'm a parent! f = %d\n", f);

printf( "almost done!\n" );


But what about threads you ask?
    A quick note on threads: A thread is a separate executable entity similar
    to a child process, except a thread is not a standalone process.

    It does not have its own memory space, instead it shares its parent's 
    memory. But shares info more quickly.


to make child run before parent, we can fake it:
   use: sleep(1);

   better:
	wait - <unistd.h>
	
		Stops a parent process from running until any child has provided
		status information to the parent via a signal.
		(usually the child has exited)

		returns the pid of the child that exited, or -1 (errno)

		wait( int *status )
		      The parameter (status) is used to store information about
		      how the process exited.

ex:
else {
     int status, r;

     r = wait( &status );
     printf("I'm a parent! f = %d\n", f);
     printf("wait returned: %d  status: %d\n", r, status);
     printf("WEXITSTATUS: %d\n", WEXITSTATUS(status) );
}


Softdev:

Aim: Stuylin'

CSS - Cascading Style Sheets

    Created to separate the presentation of an html/xml page and its content

    Basic syntax:

    	  PROPERTY: VALUE;

	  ex:
		color: lightsteelblue;


	  There are 3 ways to incorporate css into a page;
	  inline, style sheet, external style sheet.

	  inline: least useful
	  <TAG style="CSS CODE">

	  ex:
	  <p style="color: green; font-size: 2em;">...</p>

11/16/16
Systems:

Aim: Time to make an executive decision.

execlp:
	takes command line args as strings.

	int execlp( const char *filename, const char *arg, ... )

execvp:
	takes command line args as an array.

	int execvp( const char *filename, char *const argv[] )
	
	run executables by filename and argv is an array of null-terminated 
	strings to provide a value of the argv in the main function of the 
	executable file. 
	(appropriate arguments to the file/command line arguments).

	if no slash exists in filename, will look through the PATH environment 
	variable.

Both:
	<unistd.h>

	run executables and REPLACE CURRENT PROCESS.
	takes over process including pid

	returns -1 and set errno only if theres an error.


ex:
  char* file = "ls";
  char * arg[3]; //command line arguments
  arg[0] = "ls";
  arg[1] = "-al";
  arg[2] = NULL;

  int i = execvp( file, arg );
  printf( "Return: %d - error: %s\n", i, strerror(errno) );


ex:
  execlp( "ls", "ls", "-l", NULL );


SoftDev:

Anything in the <head> loads first.

External Style Sheet:
in <head>:
   <link rel="stylesheet" type="text/css" href="STYLE FILE">


11/17/16
Systems:

Aim: Let's take this to delimit!

specify path with execl
execl( "/bin/ls", "ls", "-l", NULL );

char * command[3]; - > array of pointers, but is NOT a null terminated string
     *the 3 pointers are going to assigned to immutable strings*

ex:

	command[0] = "ls";
	command[1] = "-l";
	command[2] = NULL;

	//command[1][1] = 'a'; -> will create an error if added
	/*
		char command[3][4]; -> ([][][][])([][][][])([][][][])
		//can't do s[4] = "hello"; -> only during declaration
		//must use string functions instead		
	*/

	execvp( command[0], command );


strsep - <string.h>

       Used for parsing a string with a common delimeter

       strsep( <SOURCE>, <DELIMETER> )

       Locates the first occurrence of the delimeter in a string and replaces 
       that character with NULL
       *only strsep with mutable strings!*
       
       Returns a pointer to the beginning of the original string, 
       sets the source string to the string starting at 1 index past the 
       location of the new NULL.

       Since the source variable's value is changed, it must be a pointer to a 
       string.

       To parse again, loop it.

ex:

	char line[100] = "hello-this-is-cool";
	char *s = line;
	char *p;
	while( s ) {
	       p = strsep( &s, "-" ); 
	       //no new memory is used (s is mutable pointer)

	       printf( "s: %s\n", s );
	       printf( "p: %s\n", p );
	}
	
SoftDev:

Aim: Stay classy, css.

class ex:
      <h2 class="new_chapter bold">...</h2>

Classes are specified using a . before the class name.

ex:
	.hello {
       	       font-family: "Times New Roman", Times, serif; //specific -> general
	       }

id ex:
   <div id="main_content">...</div>

ids are specified using a  # before the id name.


11/22/16
Systems:

Aim: Redirection; how does it ... SQUIRREL

File Redirection
     Changing the usual input/output behavior of a program

Command line redirection
 >
	redirects stdout to a file
	overwrites the contents of the file
	
	<COMMAND> > <FILE>
	ls > file_list

 >>
	redirects stdout to a file by appending


cheap text editor:
      cat > foo

      takes stdin and puts them into a file caled foo

2>
	redirects stderr to a file
	OVerwrites the file (2>> appends)

0: stdin
1: stdout
2: stderr

&>
	redirect stdout and stderr

<
	redirects stdin from a file
ex:
	cat > line; ls -a -l
	./a.out < line (from executor)
	immediately executes command. as soon as it reads it, it already gets
	the input, so it doesn't print "what would you like to do?".

| (pipe)
	redirect stdout from one command to stdin of the next
	ls | wc (takes output of ls to the stdin of wc)


dup2 - <unistd.h>
     redirect one file descriptor to another

     dup2( fd1, fd2 )
     	   Redirects fd2 to fd1
	   Lose any reference to the original fd2, that file is closed.


0: stdin
1: stdout -> closed -> foo.txt
2: stderr		|
3: foo.txt		v (directs to 3, lose reference to stdout)


dup - <unistd.h>

    Duplcates an existing entry in the file table
    Returns a new file descrptor for the duplicate entry

    dup(fd)
	returns the new file descriptor

ex:
	dup(1) -> creates a new file descriptor (stdout)
	dup2(3, 1) -> now foo.txt is in 1, but stdout is still in the file table at 4.




